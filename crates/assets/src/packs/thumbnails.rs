//! Contains the specific logic for generating thumbnails of assets within a given [`AssetPack`].

use bevy::prelude::{UVec2, debug, trace};
use image::{ImageFormat, ImageReader};
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};
use thiserror::Error;

/// Contains all errors related to generating / reading thumbnails.
#[derive(Debug, Error)]
pub enum AssetPackThumbnailError {
    /// An unsupported image format was passed into the [`AssetPackThumbnails`].
    ///
    /// Either the format does not support both reading/writing or was not enabled for this crate.
    #[error("Image format {0:?} is not supported for reading/writing")]
    UnsupportedImageFormat(ImageFormat),

    /// An error occurred while reading/writing the thumbnail, this only relates to IO errors itself.
    ///
    /// For encoding or decoding the image, see [`AssetPackThumbnailError::EncodingError`].
    #[error("An IO error occurred while reading/writing the thumbnail for {0}: {1}")]
    IO(PathBuf, #[source] std::io::Error),

    /// An error occurred when encoding or decoding the thumbnail.
    #[error("An error occurred while encoding/decoding the image at {1:?}")]
    EncodingError(#[source] image::ImageError, PathBuf),
}

/// Encapsulates all the thumbnail-related data structures for an [`AssetPack`].
#[derive(Debug)]
pub struct AssetPackThumbnails {
    /// The root directory where thumbnails can be generated or resolved from.
    root: PathBuf,

    /// The resolution of thumbnails that are generated by this instance.
    ///
    /// Formatted like `width`x`height`.
    resolution: UVec2,

    /// The image format used when reading/writing the thumbnails.
    format: ImageFormat,
}

impl AssetPackThumbnails {
    /// Generates a new [`AssetPackThumbnails`].
    ///
    /// The following defaults are used if `None` is passed in for these parameters:
    /// - `resolution`: defaults to `128`x`128`
    /// - `format`: defaults to [`image::ImageFormat::Webp`].
    ///
    /// # Errors
    /// This method will return an error when the `format` (if passed in) is unsupported.
    pub fn new(
        root: PathBuf,
        resolution: Option<UVec2>,
        format: Option<ImageFormat>,
    ) -> Result<Self, AssetPackThumbnailError> {
        let format = format.unwrap_or_else(|| ImageFormat::WebP);
        let resolution = resolution.unwrap_or_else(|| UVec2::splat(128));

        if !format.reading_enabled() || !format.writing_enabled() {
            return Err(AssetPackThumbnailError::UnsupportedImageFormat(format));
        }

        Ok(Self {
            root,
            resolution,
            format,
        })
    }

    /// Generates the thumbnail for an asset at the given `asset_path`.
    /// When a thumbnail already exists at the given location it will be overwritten.
    ///
    /// # Errors
    /// There are various errors that can be returned from this method.
    /// If the file itself failed to read, the image encoding failed or the output image could not
    /// be written.
    pub fn generate(
        &self,
        asset_path: impl AsRef<Path>,
        id: String,
    ) -> Result<(), AssetPackThumbnailError> {
        let _ = bevy::prelude::info_span!(
            "Thumbnail",
            path = asset_path.as_ref().to_path_buf().display().to_string()
        )
        .entered();

        debug!(
            "Opening asset {:?} for thumbnail generation",
            asset_path.as_ref().display()
        );
        let image = ImageReader::open(asset_path.as_ref())
            .map_err(|error| AssetPackThumbnailError::IO(asset_path.as_ref().to_path_buf(), error))?
            .decode()
            .map_err(|e| {
                AssetPackThumbnailError::EncodingError(e, asset_path.as_ref().to_path_buf())
            })?;

        trace!(
            "Resizing asset to thumbnail {}x{}",
            self.resolution.x, self.resolution.y
        );
        let thumbnail = image.thumbnail(self.resolution.x, self.resolution.y);

        let output = self.root.join(id).with_extension(self.extension());

        {
            let mut output_file = File::create(output.clone())
                .map_err(|error| AssetPackThumbnailError::IO(output.to_path_buf(), error))?;
            let mut buffer = BufWriter::new(&mut output_file);

            trace!("Writing thumbnail to {:?}", output.display());
            thumbnail.write_to(&mut buffer, self.format).map_err(|e| {
                AssetPackThumbnailError::EncodingError(e, asset_path.as_ref().to_path_buf())
            })?;

            buffer
                .flush()
                .map_err(|error| AssetPackThumbnailError::IO(output.to_path_buf(), error))?;
        }
        Ok(())
    }

    /// Attempts to resolve the thumbnail for a given ID.
    ///
    /// The thumbnail must be in the `root` directory and have been generated with the same image format.
    pub fn resolve(&self, id: &str) -> Option<PathBuf> {
        let path = self.root.join(id).with_extension(self.extension());

        if path.exists() { Some(path) } else { None }
    }

    /// Generate the file extension for the currently selected [`AssetPackThumbnails::format`].
    ///
    /// # Panics
    /// This method will panic if the underlying [`image::ImageFormat`] cannot provide a file extension.
    ///
    /// At the time of writing all formats provide extensions, but the library does not provide guarantees.
    fn extension(&self) -> &str {
        match self.format.extensions_str().first() {
            Some(extension) => extension,
            None => panic!("Image format {:?} has no extension", self.format),
        }
    }
}
